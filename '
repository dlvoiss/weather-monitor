import gb

import wv
import co
import db

import signal
import board
import busio
import adafruit_ads1x15.ads1115 as ADS
from adafruit_ads1x15.analog_in import AnalogIn

EAST_START       =     1
EAST_END         =  4400 #  < 4400
SOUTH_EAST_START =  4400 # >= 4400
SOUTH_EAST_END   =  8999
SOUTH_START      =  9000
SOUTH_END        = 14850
NORTH_EAST_START = 14851
NORTH_EAST_END   = 22400 #  < 22400
SOUTH_WEST_START = 22400 # >= 24000
SOUTH_WEST_END   = 27000 #  < 27000
NORTH_START      = 27000 # >= 27000
NORTH_END        = 32650 #  < 32650
WEST_START       = 32650 # >= 32650
WEST_END         = 32768  # 2^15 = 32768
NORTH_WEST_START = 32650 # >= 32650
NORTH_WEST_END   = 32768  # 2^15 = 32768

MAX_VOLTAGE = 5.336
MIN_VOLTAGE = 0.005

MAX_COUNT = 28456
MIN_COUNT = 28

MNT_VIEW_DECLINATION = -11.31

SOFT_GAIN_ADJUST = 347.7

###########################################################
# Wind Vane thread
###########################################################
class WindvaneThread(gb.threading.Thread):

    def __init__(self, group=None, target=None, name=None,
                args=(), kwargs=None, verbose=None):
        gb.threading.Thread.__init__(self, group=group, target=target,
                                     name=name)
        self.args = args
        self.kwargs = kwargs
        self.name = name
        self.kill_received = False

        return

    def send_direction(self, nm, co_q_out, msg_in, wind_dir, wind_degrees):
        req_id = msg_in[2]
        e_tm = msg_in[1]
        wind_dir_int = wv.wind_dir_str_to_int(wind_dir)
        msg = []
        msgType = co.CO_WIND_DIR
        msg.append(msgType)
        msg.append(e_tm)
        msg.append(req_id)
        msg.append(wind_dir_int)
        msg.append(wind_degrees)
        if (gb.DIAG_LEVEL & gb.WIND_DIR_MSG):
            gb.logging.info("%s sending %s(%d)" %
                            (nm, co.get_co_msg_str(msgType), msgType))
        co_q_out.put(msg)

    #---------------------------------------------------------
    # Adjust for Mountain View CA magnetic declination
    #---------------------------------------------------------
    def adjust_declination(self, degrees):
        # Handle magnetic North declination
        true_dir = degrees + MNT_VIEW_DECLINATION
        if true_dir < 0.0:
            # When direction is slightly West of North (up to 11.24
            # degrees West of North), the true North reading is
            # negative.  While the value is correct, it is better
            # to keep this value within the positive 0-360 range
            true_dir = 360.0 + true_dir
        return true_dir

    #---------------------------------------------------------
    # Get direction string from magfet degree reading
    #---------------------------------------------------------
    def get_magfet_direction_str(self, degrees):

        N_min = 348.75
        N_max = 11.25
        range = 22.5

        dir = wv.NORTH

        if degrees > N_min or degrees <= N_max:
            dir = wv.NORTH
        elif degrees <= (N_max + (1 * range)):
            dir = wv.NNE
        elif degrees <= (N_max + (2 * range)):
            dir = wv.NORTH_EAST
        elif degrees <= (N_max + (3 * range)):
            dir = wv.ENE
        elif degrees <= (N_max + (4 * range)):
            dir = wv.EAST
        elif degrees <= (N_max + (5 * range)):
            dir = wv.ESE
        elif degrees <= (N_max + (6 * range)):
            dir = wv.SOUTH_EAST
        elif degrees <= (N_max + (7 * range)):
            dir = wv.SSE
        elif degrees <= (N_max + (8 * range)):
            dir = wv.SOUTH
        elif degrees <= (N_max + (9 * range)):
            dir = wv.SSW
        elif degrees <= (N_max + (10 * range)):
            dir = wv.SOUTH_WEST
        elif degrees <= (N_max + (11 * range)):
            dir = wv.WSW
        elif degrees <= (N_max + (12 * range)):
            dir = wv.WEST
        elif degrees <= (N_max + (13 * range)):
            dir = wv.WNW
        elif degrees <= (N_max + (14 * range)):
            dir = wv.NORTH_WEST
        elif degrees <= (N_max + (15 * range)):
            dir = wv.NNW

        return dir

    #---------------------------------------------------------
    # Confirm hall sensor voltage is within expected range
    #---------------------------------------------------------
    def check_max_v(self, volts):

        global MAX_VOLTAGE

        new_max = False
        if volts > MAX_VOLTAGE and volts < 6.0:
            MAX_VOLTAGE = volts
            new_max = True

        return new_max

    #---------------------------------------------------------
    # Confirm hall sensor voltage is within expected range
    #---------------------------------------------------------
    def check_min_v(self, volts):

        global MIN_VOLTAGE

        new_min = False
        if volts < MIN_VOLTAGE and volts > 0.0:
            MIN_VOLTAGE = volts
            new_min = True

        return new_min

    #---------------------------------------------------------
    # Confirm hall sensor count is within expected range
    #---------------------------------------------------------
    def check_max_c(self, count):

        global MAX_COUNT

        new_max = False
        if count > MAX_COUNT and count < 35000:
            MAX_COUNT = count
            new_max = True

        return new_max

    #---------------------------------------------------------
    # Confirm hall sensor count is within expected range
    #---------------------------------------------------------
    def check_min_c(self, count):

        global MIN_COUNT

        new_min = False
        if count < MIN_COUNT and count >= 0:
            MIN_COUNT = count
            new_min = True

        return new_min

    #---------------------------------------------------------
    # Calculate hall sensor degrees / volt
    #---------------------------------------------------------
    def calc_step_v(self, min_volts, max_volts):

        # degrees/volt == 360.0 / voltage range

         range = max_volts - min_volts
         deg_step = range / 360.0

         #if gb.DIAG_LEVEL & gb.WV_RANGE:
         gb.logging.info(
                  "degrees/volt: %.3f MIN: %.3f v, MAX %.3f v, range: %.3f v" %
                  (deg_step, min_volts, max_volts, range))

         return deg_step

    #---------------------------------------------------------
    # Calculate hall sensor degrees / count
    #---------------------------------------------------------
    def calc_step_c(self, min_count, max_count):

        # degrees/count == 360.0 / counter range

         range = max_count - min_count
         deg_step = float(range) / 360.0

         #if gb.DIAG_LEVEL & gb.WV_RANGE:
         gb.logging.info("degrees/count: %.3f MIN: %d, MAX %d, range %d" %
                          (deg_step, min_count, max_count, range))

         return deg_step

    #---------------------------------------------------------
    # Use inverse if shaft points downward
    #---------------------------------------------------------
    def adjust_shaft_down(self, dir):
        if dir > 180.0:
            dir = 180.0 - (dir - 180.0)
        elif dir < 180.0:
            dir = 180.0 + (180.0 - dir)
        return dir

    #---------------------------------------------------------
    # Voltage corresponds to inverse direction if shaft points downward
    # i.e., 270 degrees is due East, 90 degrees is due West
    # 180 degrees is still South and 0 degrees is North
    #---------------------------------------------------------
    def calc_dir_v(self, volts, min_v, max_v):
        # degrees/volt == 360.0 / voltage range
        # degrees = volts * degrees/volt
        dir = (volts * 360.0) / (max_v - min_v)
        dir_in_degrees = self.adjust_shaft_down(dir)
        return dir_in_degrees

    #---------------------------------------------------------
    # Count corresponds to inverse direction if shaft points downward
    #---------------------------------------------------------
    def calc_dir_c(self, count, min_c, max_c):
        # degrees/count == 360.0 / counter range
        # degrees = count * degrees/count
        dir = (float(count) * 360.0) / (float(max_c) - float(min_c))
        dir_in_degrees = self.adjust_shaft_down(dir)
        return dir_in_degrees

    #---------------------------------------------------------
    # Process magfet readings from ADS1115
    #---------------------------------------------------------
    def get_degrees(self, volts, raw):

        if self.check_min_v(volts) or self.check_max_v(volts):
            degree_step = self.calc_step_v(MIN_VOLTAGE, MAX_VOLTAGE)
        if self.check_min_c(raw) or self.check_max_c(raw):
            count_step = self.calc_step_c(MIN_COUNT, MAX_COUNT)

        direction_v = self.calc_dir_v(volts, MIN_VOLTAGE, MAX_VOLTAGE)
        direction_v = round(direction_v + 0.05, 1)

        direction_c = self.calc_dir_c(raw, MIN_COUNT, MAX_COUNT)
        direction_c = round(direction_c + 0.05, 1)

        return direction_v, direction_c

    #---------------------------------------------------------
    # Send keep-alive (I am alive) message to DB via Coordinator
    #---------------------------------------------------------
    def send_wv_keep_alive(self, co_q_out):
        db_msgType = db.DB_WV_ALIVE
        coInfo = []
        coInfo.append(db_msgType)

        if (gb.DIAG_LEVEL & gb.SEND_TO_DB):
            gb.logging.info("Sending %s(%d) via Coordinator" %
                     (db.get_db_msg_str(db_msgType),db_msgType))
        co_q_out.put(coInfo)

    ###########################################################
    # Wind Vane thread run loop
    ###########################################################
    def run(self):
        gb.logging.info("Running %s thread" % (self.name))
        if (gb.DIAG_LEVEL & gb.WIND_DIR_DETAIL):
            gb.logging.info(self.args)

        wv_q_in = self.args[0]
        co_q_out = self.args[1]
        end_event = self.args[2]

        # ADS115 is 16-bit ADC
        i2c = busio.I2C(board.SCL, board.SDA)
        # Create the ADS object and specify the gain
        ads = ADS.ADS1115(i2c)
        # ADS gain
        # Gain can change based on the voltage signal - Gain of 1
        # is typically enough for a many sensors, but range
        # is limited to 0-4.xv
        #  - Gain of 1 results in max voltage of 4.0x and about
        #    1/4 of the hall effect sensor rotation pegs at 4.096v
        #  - Need to use 2/3 gain to get full 0-5v (0-6.xv) range
        #    and a varying voltage through all 360 degrees
        #ads.gain = 1
        ads.gain = 2.0/3.0

        chan0 = AnalogIn(ads, ADS.P0)  # Windvane direction
        chan1 = AnalogIn(ads, ADS.P1)  # Magfet windvane direction
        chan2 = AnalogIn(ads, ADS.P2)  # Unused
        chan3 = AnalogIn(ads, ADS.P3)  # Unused
        gb.logging.info("ADS1115 (i2c) initialized")

        magfet_dir_str = ""

        alive_counter = 0

        degree_step = self.calc_step_v(MIN_VOLTAGE, MAX_VOLTAGE)
        count_step = self.calc_step_c(MIN_COUNT, MAX_COUNT)

        true_magfet_degrees = 0.0

        logging_time_next = gb.datetime.now()

        while not end_event.isSet():
            wv_data = ""
            while (not wv_q_in.empty()):
                msg = wv_q_in.get()
                msgType = msg[0]
                if ((gb.DIAG_LEVEL & gb.WIND_DIR_MSG) and
                    (gb.DIAG_LEVEL & gb.WIND_DIR_DETAIL)):
                    gb.logging.info("%s: Received %s(%d)" %
                            (self.name, wv.get_wv_msg_str(msgType), msgType))

                if (msgType == wv.WV_EXIT):
                    gb.logging.info("%s: Cleanup prior to exit" % (self.name))

                elif (msgType == wv.WV_GET_DIRECTION):
                    if (gb.DIAG_LEVEL & gb.WIND_DIR_MSG):
                        gb.logging.info("%s: Received %s(%d)" %
                            (self.name, wv.get_wv_msg_str(msgType), msgType))
                    self.send_direction(self.name, co_q_out, msg,
                                        magfet_dir_str, true_magfet_degrees)

                else:
                    gb.logging.error("Invalid WD message type: %d" % (msgType))
                    gb.logging.error(msg)

                gb.time.sleep(0.1)

            #----------------------------------------
            # chan0 is resistor-based weather vane
            #----------------------------------------
            wv_r_volts = chan0.voltage
            wv_r_value = chan0.value
            #----------------------------------------
            # chan1 is hall sensor (magfet) weather vane
            #----------------------------------------
            wv_hall_volts = chan1.voltage
            wv_hall_value = chan1.value

            wv_r_dir_str = ""
            wv_r_dir_str2 = ""

            #----------------------------------------
            # Get hall sensor (magfet) wind direction
            #----------------------------------------
            degrees_v, degrees_c = self.get_degrees(wv_hall_volts, wv_hall_value)
            # Apply software gain to bring direction up to 360 degrees
            degree_gain = degrees_v * 360.0/SOFT_GAIN_ADJUST
            if degree_gain >= 360.0:
                degree_gain = degree_gain - 360.0
            true_magfet_degrees = self.adjust_declination(degree_gain)
            magfet_dir_str = self.get_magfet_direction_str(true_magfet_degrees)

            if (gb.DIAG_LEVEL & gb.WIND_DIR_DETAIL):
                gb.logging.info("wv1 voltage: %.3f, wv1 value %d" %
                                (wv_hall_volts, wv_hall_value))
                gb.logging.info("degrees_v: %.1f, degrees_c %.1f "
                                "degree_gain %.1f" %
                                (degrees_v, degrees_c, degree_gain))
                gb.logging.info("degrees true: %.1f, dir %s" %
                                (true_magfet_degrees, magfet_dir_str))

            #----------------------------------------
            # Determine 8-point direction for resistor windvane
            #----------------------------------------
            if ((wv_r_value >= EAST_START) and (wv_r_value < EAST_END)):
                wv_r_dir_str = wv.EAST
            elif ((wv_r_value >= SOUTH_EAST_START) and (wv_r_value <= SOUTH_EAST_END)):
                wv_r_dir_str = wv.SOUTH_EAST
            elif ((wv_r_value >= SOUTH_START) and (wv_r_value <= SOUTH_END)):
                wv_r_dir_str = wv.SOUTH
            elif ((wv_r_value >= NORTH_EAST_START) and (wv_r_value <= NORTH_EAST_END)):
                wv_r_dir_str = wv.NORTH_EAST
            elif ((wv_r_value >= SOUTH_WEST_START) and (wv_r_value <= SOUTH_WEST_END)):
                wv_r_dir_str = wv.SOUTH_WEST
            elif ((wv_r_value >= NORTH_START) and (wv_r_value <= NORTH_END)):
                wv_r_dir_str = wv.NORTH
            elif ((wv_r_value >= WEST_START) and (wv_r_value <= WEST_END)):
                wv_r_dir_str = wv.WEST
                wv_r_dir_str2= wv.NORTH_WEST
            else:
                wv_r_dir_str = "Invalid"
                logging_now = gb.datetime.now()
                if (logging_now > logging_time_next):
                    logging_time_next =  logging_now + gb.timedelta(seconds=60)
                    gb.logging.error("ERROR: Wind direction: %s, %d, %0.5f" %
                                     (wv_r_dir_str, wv_r_value, wv_r_volts))

            #gb.logging.info("Wind Dir: %s %s %5d %.5f" %
            #                 (wv_r_dir_str, wv_r_dir_str2, wv_r_value, wv_r_volts))
            #gb.time.sleep(5)  # one-second in non-debug

            if (gb.DIAG_LEVEL & gb.WIND_DIR_DETAIL):
                gb.logging.info("Wind Dir: %s %s %5d %.5f" %
                             (wv_r_dir_str, wv_r_dir_str2, wv_r_value, wv_r_volts))
            elif (gb.DIAG_LEVEL & gb.WIND_DIR):
                gb.logging.info("Wind Dir: %s %s" % (wv_r_dir_str, wv_r_dir_str2))

            if alive_counter >= 30:
                self.send_wv_keep_alive(co_q_out)
                alive_counter = 0
            alive_counter += 1

            if (gb.DIAG_LEVEL & gb.WIND_DIR_DETAIL):
                gb.time.sleep(5)
            else:
                gb.time.sleep(1)

        gb.logging.info("Exiting thread %s" % (self.name))
        return
